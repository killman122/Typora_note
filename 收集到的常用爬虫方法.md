# 爬虫解决tls指纹问题总结

原创 洛小哥 [Python爬虫大数据可视化](javascript:void(0);) *2023-08-23 10:24* *发表于湖南*

收录于合集#JavaScript逆向12个

**特别声明**：本公众号文章只作为学术研究，不用于其它不法用途；如有侵权请联系作者删除。



***START\***





![图片](https://mmbiz.qpic.cn/mmbiz_gif/m5qEELWt8A4g05V4rHL4vZMyGTE8ic691Wt6FFglTFeeibsPZT5F1vAiafn06J37WwvPkkGVX2B14Qh3gpPmic5Dpw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&tp=wxpic)

  我是洛小哥，有着执着的追求，信奉终身成长，不定义自己，热爱技术但不拘泥于技术，爱好分享，喜欢读书和乐于结交朋友，欢迎加我微信与我交朋友。

  分享日常学习中关于爬虫、逆向和分析的一些思路，文中若有错误的地方，欢迎大家多多交流指正☀️

### TLS 指纹

首先来回顾一下什么是 TLS 指纹。如果已经了解，可以直接跳到后边的 curl_cffi 部分。

现在绝大多数的网站都已经使用了 HTTPS，要建立 HTTPS 链接，服务器和客户端之间首先要进行 TLS 握手，在握手过程中交换双方支持的 TLS 版本，加密算法等信息。不同的客户端之间的差异 很大，而且一般这些信息还都是稳定的，所以服务端就可以根据 TLS 的握手信息来作为特征，识别 一个请求是普通的用户浏览器访问，还是来自 Python 脚本等的自动化访问。

JA3 是生成 TLS 指纹的一个常用算法。它的工作原理也很简单，大概就是把以上特征拼接并求 md5。

有证据表明，阿里云、华为云、Akamai 和 Cloudflare 都在使用 TLS 指纹技术来识别机器访问流量。Akamai 更是直接在宣传稿中说明了在通过 TLS 指纹技术检测非法请求。

方法一

为了完美模拟浏览器，国外有大佬给 curl 打了一些 patch，把相应组件全部都替换成了浏览器使用 库，连版本都保持一致，这样就得到了和浏览器完全一样的指纹，这个库是：curl-impersonate

Python 中早就有 curl 的 binding -- pycurl，但是非常难用，安装的时候总是出现编译错误；接口 也很低级，相比 requests，甚至 urllib，用起来都比较费劲。curl-impersonate 的作者提出使用 环境变量 + 替换 libcurl 来在不同语言中使用 curl-impersonate，但是似乎 pycurl 没法工作。于是乎，我直接另起炉灶，写了一个 curl(-impersonate) 的 Python binding.

相比 pycurl，有以下优点：

- 原生支持 curl-impersonate
- pip install 直接是二进制包，无需编译，也就不会有编译错误
- 提供了一个简单的 requests-like 接口

废话少说，看代码吧！

```
pip install curl_cffi
```

使用起来也很简单

```
from curl_cffi import requests

# 注意这个 impersonate 参数，指定了模拟哪个浏览器
r = requests.get("https://tls.browserleaks.com/json", impersonate="chrome101")

print(r.json())
# output: {'ja3_hash': '53ff64ddf993ca882b70e1c82af5da49'
```

我们可以看到，输出的 JA3 指纹和浏览器中的指纹一模一样！



**第二种**

# Python-TLS-Client

Python-TLS-Client is an advanced HTTP library based on requests and tls-client.

# Installation

```
pip install tls-client
```

# Examples

The syntax is inspired by requests, so its very similar and there are only very few things that are different.

**如果是GET请求请使用这一个**

```python3
import tls_client



# You can also use the following as `client_identifier`:

# Chrome --> chrome_103, chrome_104, chrome_105, chrome_106, chrome_107, chrome_108, chrome109, Chrome110,

#            chrome111, chrome112

# Firefox --> firefox_102, firefox_104, firefox108, Firefox110

# Opera --> opera_89, opera_90

# Safari --> safari_15_3, safari_15_6_1, safari_16_0

# iOS --> safari_ios_15_5, safari_ios_15_6, safari_ios_16_0

# iPadOS --> safari_ios_15_6

# Android --> okhttp4_android_7, okhttp4_android_8, okhttp4_android_9, okhttp4_android_10, okhttp4_android_11,

#             okhttp4_android_12, okhttp4_android_13



session = tls_client.Session(

    client_identifier="chrome112",

    random_tls_extension_order=True

)



res = session.get(

    "https://www.example.com/",

    headers={

        "key1": "value1",

    },

    proxy="http://user:password@host:port"

)
```



使用起来也很简单

```

```

- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 

```
import tls_clientsession = tls_client.Session(
    client_identifier="chrome112",
    random_tls_extension_order=True
)
r = session.get("https://tls.browserleaks.com/json")
print(r.json())# output: {'ja3_hash': '53ff64ddf993ca882b70e1c82af5da49'
```

我们可以看到，输出的 JA3 指纹和浏览器中的指纹一模一样！



**如果是POST请求请使用这一个**

```python3
import tls_client



session = tls_client.Session(

    ja3_string="771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,0-23-65281-10-11-35-16-5-13-18-51-45-43-27-17513,29-23-24,0",

    h2_settings={

        "HEADER_TABLE_SIZE": 65536,

        "MAX_CONCURRENT_STREAMS": 1000,

        "INITIAL_WINDOW_SIZE": 6291456,

        "MAX_HEADER_LIST_SIZE": 262144

    },

    h2_settings_order=[

        "HEADER_TABLE_SIZE",

        "MAX_CONCURRENT_STREAMS",

        "INITIAL_WINDOW_SIZE",

        "MAX_HEADER_LIST_SIZE"

    ],

    supported_signature_algorithms=[

        "ECDSAWithP256AndSHA256",

        "PSSWithSHA256",

        "PKCS1WithSHA256",

        "ECDSAWithP384AndSHA384",

        "PSSWithSHA384",

        "PKCS1WithSHA384",

        "PSSWithSHA512",

        "PKCS1WithSHA512",

    ],

    supported_versions=["GREASE", "1.3", "1.2"],

    key_share_curves=["GREASE", "X25519"],

    cert_compression_algo="brotli",

    pseudo_header_order=[

        ":method",

        ":authority",

        ":scheme",

        ":path"

    ],

    connection_flow=15663105,

    header_order=[

        "accept",

        "user-agent",

        "accept-encoding",

        "accept-language"

    ]

)



res = session.post(

    "https://www.example.com/",

    headers={

        "key1": "value1",

    },

    json={

        "key1": "key2"

    }

)
```



今天分享到这里就结束了，欢迎大家关注下期文章，我们不见不散⛽️



------





***END***





![图片](https://mmbiz.qpic.cn/mmbiz_gif/m5qEELWt8A4g05V4rHL4vZMyGTE8ic691Wt6FFglTFeeibsPZT5F1vAiafn06J37WwvPkkGVX2B14Qh3gpPmic5Dpw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&tp=wxpic)

  我是洛小哥，有着执着的追求，信奉终身成长，不定义自己，热爱技术但不拘泥于技术，爱好分享，喜欢读书和乐于结交朋友，欢迎加我微信与我交朋友。

  分享日常学习中关于爬虫、逆向和分析的一些思路，文中若有错误的地方，欢迎大家多多交流指正☀️

![图片](https://mmbiz.qpic.cn/mmbiz/SRo2Q9icoGIu41UQjhvHkZm5aMyP38jxbib14avKYCDfPFFibSqGLJ6ribYzA1jtf4wkAA6jxHw6mpW713nuDIlicBQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1&tp=wxpic)



收录于合集 #JavaScript逆向

 12个

上一篇证券交易所数据采集与逆向分析

阅读 44

![img](http://mmbiz.qpic.cn/mmbiz_png/SRo2Q9icoGIsWibCrlJGONPspWRiatFdpSuQUwxuO8VichSxrgcdONWAVcQm9hG1UT49X4T4V5aPiaz7EWOvPx1ZF2Q/300?wx_fmt=png)

Python爬虫大数据可视化

分享收藏

在看

赞